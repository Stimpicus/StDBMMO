# Server-Client Spawn Flow Implementation

## Overview
This PR implements the complete flow for spawning player characters after connecting to the server. The implementation allows the server to determine if a player is new or existing, create/assign a PlayerCharacter, and coordinate with the client to spawn the pawn.

## Changes Made

### Server-Side (Rust - server-rust crate)

#### 1. PlayerCharacter Schema Changes (`server-rust/src/players.rs`)
- **Added `needs_spawn: bool` field** to the `PlayerCharacter` struct
  - This field is set to `true` when a new character is created
  - The client monitors this field to know when to spawn/possess the pawn
  - The field is cleared to `false` after the client successfully spawns

#### 2. New Reducer: `player_spawned` (`server-rust/src/players.rs`)
```rust
#[spacetimedb::reducer]
pub fn player_spawned(ctx: &ReducerContext, character_id: u32) -> Result<(), String>
```
- Called by the client after successfully spawning and possessing the pawn
- Clears the `needs_spawn` flag for the character
- Prevents the client from repeatedly trying to spawn

#### 3. Updated Spawn Functions
- Modified `spawn_player_character_at` to set `needs_spawn = true` when creating characters
- This ensures new characters are flagged for client-side spawning

### Client-Side (Unreal C++)

#### 1. Subscription Handling (`StDbConnectSubsystem.cpp`)
Updated `HandleSubscriptionApplied` to:
- Find the local player in the `Players` table by matching `LocalIdentity`
- Find the corresponding `PlayerCharacter` for that player
- Detect when `needs_spawn` is true
- **TODO**: Implement actual world loading and pawn spawning (currently placeholder)

The flow is:
1. Search Players table for entry matching LocalIdentity
2. Extract PlayerId from that player
3. Search PlayerCharacters table for entry with matching PlayerId
4. If found and NeedsSpawn is true, trigger spawn sequence

#### 2. Input Forwarding (`client_unrealCharacter.cpp/h`)
- Added `SendTransformToServer()` method
  - Accesses the `UStDbConnectSubsystem` via game instance
  - Converts UE4 transform to SpacetimeDB `FTransformType`
  - Calls `UpdatePlayerInput` reducer with current position/rotation

- Modified `DoMove()` and `DoLook()` methods
  - Added calls to `SendTransformToServer()` when locally controlled
  - This sends player input to the server for authoritative state updates

#### 3. Generated Bindings Updates

**PlayerCharacterType.g.h**:
- Added `NeedsSpawn` boolean field
- Updated equality operators and hash functions
- Updated BSATN struct macro

**PlayerSpawned.g.h** (new file):
- Created reducer arguments struct `FPlayerSpawnedArgs`
- Created reducer class `UPlayerSpawnedReducer`
- Follows the same pattern as other reducers

**SpacetimeDBClient.g.h/cpp**:
- Added `PlayerSpawned` to `EReducerTag` enum
- Added `FPlayerSpawnedArgs` to the `FReducer` variant
- Added static factory method `FReducer::PlayerSpawned()`
- Added `URemoteReducers::PlayerSpawned(uint32 CharacterId)` method
- Added dispatcher logic for the `player_spawned` reducer

## Implementation Status

### âœ… Completed
- [x] Server-side schema changes (needs_spawn field)
- [x] Server-side player_spawned reducer
- [x] Client-side subscription monitoring
- [x] Client-side input forwarding to server
- [x] All generated binding updates
- [x] Rust server builds successfully

### ðŸš§ Remaining Work (Marked with TODO in code)
The following items are stubbed out with TODO comments and need to be implemented based on the specific game/level setup:

1. **World Loading** (`StDbConnectSubsystem.cpp:HandleSubscriptionApplied`)
   - Load the "Lvl_World" level when spawn is needed
   - This requires UE4 level streaming or level loading API

2. **Pawn Spawning** (`StDbConnectSubsystem.cpp:HandleSubscriptionApplied`)
   - Spawn the player pawn at the transform from `PlayerChar.Transform`
   - Get reference to the appropriate pawn class to spawn

3. **Pawn Possession** (`StDbConnectSubsystem.cpp:HandleSubscriptionApplied`)
   - Possess the newly spawned pawn with the player controller
   - Call `Conn->Reducers->PlayerSpawned(PlayerChar.CharacterId)` after possession

4. **Client-Side Prediction/Reconciliation**
   - Currently sends all transforms to server
   - May want to throttle updates (e.g., only on significant changes)
   - May want to implement client-side prediction and server reconciliation

## Testing Notes

### Server Build
The Rust server builds successfully with all changes:
```bash
cd server-rust && cargo build
```

### Client Bindings
The client bindings have been manually updated to match what would be generated by:
```bash
spacetime generate --lang unrealcpp --uproject-dir ../client_unreal --project-path ./ --module-name client_unreal
```

**Important**: After deploying the Rust server module with the new schema, you should run the above command to regenerate bindings to ensure they're perfectly in sync.

## Integration Steps

1. **Deploy Server Module**
   - Build the Rust module: `cd server-rust && cargo build`
   - Publish to SpacetimeDB: `spacetime publish <module-name>`

2. **Regenerate Client Bindings** (Optional but recommended)
   - Run: `cd server-rust && spacetime generate ...` (see gen.bat)

3. **Complete TODOs**
   - Implement world loading in `StDbConnectSubsystem::HandleSubscriptionApplied`
   - Implement pawn spawning logic
   - Test the complete flow

4. **Test Flow**
   - Connect with new player â†’ should create Player + PlayerCharacter with needs_spawn=true
   - Client should detect this and spawn pawn (once TODO is implemented)
   - Client should call player_spawned reducer
   - Disconnect and reconnect â†’ character should be restored without needs_spawn

## Architecture Notes

### Why needs_spawn instead of server-initiated reducers?
The implementation uses a subscription-based approach where:
- Server sets a flag (`needs_spawn`) on the character
- Client monitors subscriptions and reacts to the flag
- Client calls back to server when done (`player_spawned`)

This is simpler than trying to have the server call client-side functions, which isn't directly supported in the SpacetimeDB model.

### Input Flow
1. Player provides input â†’ UE4 character controller
2. UE4 applies movement locally (client-side prediction)
3. Character calls `SendTransformToServer()`
4. Server receives `update_player_input` reducer
5. Server updates authoritative state in PlayerCharacter table
6. Client receives subscription update with authoritative state
7. Client can reconcile if needed (not yet implemented)

## Files Modified

### Server (Rust)
- `server-rust/src/players.rs` - Added needs_spawn field and player_spawned reducer

### Client (Unreal C++)
- `client_unreal/Source/client_unreal/private/StDbConnectSubsystem.cpp` - Subscription handling
- `client_unreal/Source/client_unreal/private/client_unrealCharacter.cpp` - Input forwarding
- `client_unreal/Source/client_unreal/public/client_unrealCharacter.h` - Method declarations
- `client_unreal/Source/client_unreal/public/ModuleBindings/Types/PlayerCharacterType.g.h` - Schema update
- `client_unreal/Source/client_unreal/public/ModuleBindings/Reducers/PlayerSpawned.g.h` - New reducer
- `client_unreal/Source/client_unreal/public/ModuleBindings/SpacetimeDBClient.g.h` - Reducer registration
- `client_unreal/Source/client_unreal/private/ModuleBindings/SpacetimeDBClient.g.cpp` - Reducer implementation

## Future Enhancements

1. **Throttle input updates** - Don't send every frame, send on significant changes or at intervals
2. **Client-side prediction** - Smooth movement by predicting and reconciling with server
3. **Multiple characters per player** - Currently assumes one character per player
4. **Spawn location logic** - More sophisticated spawn point selection
5. **Loading screens** - Show loading UI while waiting for world load
